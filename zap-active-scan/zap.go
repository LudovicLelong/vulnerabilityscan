package active_scan

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"
)

const (
	ApiKey     = "mh20la1c8igrtk0h6ovbd5evtl"
	ZapBaseURL = "http://localhost:8081" // Assurez-vous que c'est l'URL correcte
)

type ZAPv2 struct {
	APIKey  string
	BaseURL string
	Client  *http.Client
}

func NewZAPv2() *ZAPv2 {
	return &ZAPv2{
		APIKey:  ApiKey,
		BaseURL: ZapBaseURL,
		Client:  &http.Client{Timeout: 10 * time.Second}, // Timeout de 10 secondes
	}
}

func (zap *ZAPv2) Request(endpoint string, params url.Values) ([]byte, error) {
	params.Add("apikey", zap.APIKey)
	fullURL := fmt.Sprintf("%s%s?%s", zap.BaseURL, endpoint, params.Encode())

	fmt.Printf("Request URL: %s\n", fullURL) // Log supplémentaire

	resp, err := zap.Client.Get(fullURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	fmt.Printf("Response Body: %s\n", string(body)) // Log supplémentaire

	return body, nil
}

func (zap *ZAPv2) StopScan() error {
	params := url.Values{}
	body, err := zap.Request("/JSON/ascan/action/stopAllScans/", params)
	if err != nil {
		return fmt.Errorf("failed to stop previous scans: %v", err)
	}
	fmt.Printf("Stop Scan Response: %s\n", string(body)) // Log supplémentaire
	return nil
}

func (zap *ZAPv2) StartActiveScan(target string) (string, error) {
	params := url.Values{}
	params.Add("url", target)
	params.Add("recurse", "true")
	params.Add("inScopeOnly", "true")

	resp, err := zap.Request("/JSON/ascan/action/scan/", params)
	if err != nil {
		return "", fmt.Errorf("failed to start active scan: %v", err)
	}

	var result map[string]interface{}
	if err := json.Unmarshal(resp, &result); err != nil {
		return "", fmt.Errorf("failed to parse scan response: %v", err)
	}

	fmt.Printf("Scan Start Response: %v\n", result) // Log supplémentaire

	scanID, ok := result["scan"].(string)
	if !ok {
		return "", fmt.Errorf("scan ID not found in response")
	}

	return scanID, nil
}

func (zap *ZAPv2) ScanStatus(scanID string) (string, error) {
	params := url.Values{}
	params.Add("scanId", scanID)

	resp, err := zap.Request("/JSON/ascan/view/status/", params)
	if err != nil {
		return "", fmt.Errorf("failed to get scan status: %v", err)
	}

	var result map[string]interface{}
	if err := json.Unmarshal(resp, &result); err != nil {
		return "", fmt.Errorf("failed to parse status response: %v", err)
	}

	fmt.Printf("Scan Status Response: %v\n", result) // Log supplémentaire

	status, ok := result["status"].(string)
	if !ok {
		return "", fmt.Errorf("status not found in response")
	}

	return status, nil
}

func (zap *ZAPv2) ScanResults(target string) ([]map[string]interface{}, error) {
	params := url.Values{}
	params.Add("baseurl", target) // Utiliser l'URL cible réelle ici

	resp, err := zap.Request("/JSON/core/view/alerts/", params)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve scan results: %v", err)
	}

	var result map[string]interface{}
	if err := json.Unmarshal(resp, &result); err != nil {
		return nil, fmt.Errorf("failed to parse results response: %v", err)
	}

	fmt.Printf("Scan Results Response: %v\n", result) // Log supplémentaire

	alerts, ok := result["alerts"].([]interface{})
	if !ok {
		return nil, fmt.Errorf("alerts not found in response")
	}

	var detailedResults []map[string]interface{}
	for _, alert := range alerts {
		alertMap, ok := alert.(map[string]interface{})
		if !ok {
			continue
		}
		detailedResults = append(detailedResults, alertMap)
	}

	return detailedResults, nil
}
