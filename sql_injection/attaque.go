package sql_injection

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

type SQLInjectionRequest struct {
	APIKey string   `json:"api_key"`
	URLs   []string `json:"urls"`
}

type SQLInjectionResponse struct {
	URL    string `json:"url"`
	Status string `json:"status"`
	Error  string `json:"error,omitempty"`
}

func StartSQLInjectionHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("Received request to start SQL Injection scan")

	// Lire et vérifier le corps de la requête
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Unable to read request body", http.StatusBadRequest)
		log.Printf("Error reading request body: %v", err)
		return
	}
	log.Printf("Request body: %s", string(body))

	var request SQLInjectionRequest
	err = json.Unmarshal(body, &request)
	if err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		log.Printf("Error decoding JSON: %v", err)
		return
	}

	log.Printf("Decoded request: %+v\n", request)

	zapClient := NewZAPv2WithAPIKey(request.APIKey)
	results := []SQLInjectionResponse{}
	for _, url := range request.URLs {
		status := "success"
		log.Printf("Starting SQL Injection scan for URL: %s\n", url)
		scanID, err := zapClient.SQLInjectionScan(url)
		if err != nil {
			status = "error"
			result := SQLInjectionResponse{
				URL:    url,
				Status: status,
				Error:  fmt.Sprintf("%v", err),
			}
			results = append(results, result)
			continue
		}
		log.Printf("Scan ID for URL %s: %s\n", url, scanID)

		// Attendre que le scan soit terminé
		timeout := time.Now().Add(10 * time.Minute) // Augmenter le timeout
		var lastStatus string
		var sameStatusCount int
		for {
			status, err := zapClient.SQLInjectionStatus(scanID)
			if err != nil {
				log.Printf("Error checking SQL Injection status for URL %s: %v\n", url, err)
				status = "error"
				break
			}
			log.Printf("SQL Injection status for URL %s: %s%%\n", url, status)
			if status == "100" {
				log.Printf("SQL Injection scan for URL %s completed at 100%%\n", url)
				break
			}
			if time.Now().After(timeout) {
				log.Printf("Timeout reached for SQL Injection scan for URL %s\n", url)
				status = "timeout"
				break
			}
			if status == lastStatus {
				sameStatusCount++
			} else {
				sameStatusCount = 0
			}
			lastStatus = status
			if sameStatusCount > 30 { // Arrêter si le statut reste inchangé pendant 30 itérations
				log.Printf("Scan stuck at %s%% for URL %s\n", status, url)
				break
			}
			time.Sleep(2 * time.Second)
		}

		// Récupérer les résultats
		log.Printf("Retrieving results for scan ID %s for URL %s\n", scanID, url)
		detailedResults, err := zapClient.SQLInjectionResults(scanID)
		if err != nil {
			log.Printf("Error retrieving SQL Injection results for URL %s: %v\n", url, err)
			status = "error"
			results = append(results, SQLInjectionResponse{
				URL:    url,
				Status: status,
				Error:  fmt.Sprintf("%v", err),
			})
			continue
		}

		if len(detailedResults) == 0 {
			log.Printf("No results found for scan ID %s for URL %s\n", scanID, url)
		}

		for _, result := range detailedResults {
			alert, err := json.Marshal(result)
			if err != nil {
				log.Printf("Error marshalling alert for URL %s: %v\n", url, err)
				continue
			}
			results = append(results, SQLInjectionResponse{
				URL:    url,
				Status: "alert",
				Error:  string(alert),
			})
			log.Printf("Alert for URL %s: %s\n", url, string(alert))
		}
	}

	response := map[string]interface{}{
		"results": results,
	}

	log.Printf("Final results: %+v\n", response)

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.Printf("Error encoding response: %v", err)
	}
}

func StartSQLInjectionScan(apiKey, url string) (string, error) {
	zapBaseURL := "http://localhost:8080" // URL de base de l'API ZAP
	apiEndpoint := fmt.Sprintf("%s/JSON/ascan/action/scan/?apikey=%s&url=%s", zapBaseURL, apiKey, url)

	resp, err := http.Get(apiEndpoint)
	if err != nil {
		log.Printf("Error starting SQL Injection scan for URL %s: %v", url, err)
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		errMsg := fmt.Sprintf("Non-OK HTTP status: %s, response body: %s", resp.Status, string(body))
		log.Println(errMsg)
		return "", fmt.Errorf(errMsg)
	}

	var response map[string]interface{}
	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&response)
	if err != nil {
		return "", fmt.Errorf("error parsing SQL injection scan response: %v", err)
	}

	scanID, ok := response["scan"].(string)
	if !ok {
		return "", fmt.Errorf("scan ID not found in response")
	}

	log.Printf("Started SQL Injection scan for URL %s with scan ID %s", url, scanID)
	return scanID, nil
}

func SQLInjectionStatus(apiKey, scanID string) (string, error) {
	zapBaseURL := "http://localhost:8080"
	apiEndpoint := fmt.Sprintf("%s/JSON/ascan/view/status/?apikey=%s&scanId=%s", zapBaseURL, apiKey, scanID)

	resp, err := http.Get(apiEndpoint)
	if err != nil {
		log.Printf("Error checking SQL Injection status for scan ID %s: %v", scanID, err)
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		errMsg := fmt.Sprintf("Non-OK HTTP status: %s, response body: %s", resp.Status, string(body))
		log.Println(errMsg)
		return "", fmt.Errorf(errMsg)
	}

	var response map[string]interface{}
	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&response)
	if err != nil {
		return "", fmt.Errorf("error parsing SQL injection status response: %v", err)
	}

	status, ok := response["status"].(string)
	if !ok {
		return "", fmt.Errorf("status not found in response")
	}

	return status, nil
}

func SQLInjectionResults(apiKey, scanID string) ([]map[string]interface{}, error) {
	zapBaseURL := "http://localhost:8080"
	apiEndpoint := fmt.Sprintf("%s/JSON/core/view/alerts/?apikey=%s&baseurl=%s", zapBaseURL, apiKey, scanID)

	resp, err := http.Get(apiEndpoint)
	if err != nil {
		log.Printf("Error retrieving SQL Injection results for scan ID %s: %v", scanID, err)
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		errMsg := fmt.Sprintf("Non-OK HTTP status: %s, response body: %s", resp.Status, string(body))
		log.Println(errMsg)
		return nil, fmt.Errorf(errMsg)
	}

	var response map[string]interface{}
	decoder := json.NewDecoder(resp.Body)
	err = decoder.Decode(&response)
	if err != nil {
		return nil, fmt.Errorf("error parsing SQL injection results response: %v", err)
	}

	alerts, ok := response["alerts"].([]interface{})
	if !ok {
		return nil, fmt.Errorf("alerts not found in response")
	}

	var detailedResults []map[string]interface{}
	for _, alert := range alerts {
		alertMap, ok := alert.(map[string]interface{})
		if !ok {
			continue
		}
		detailedResults = append(detailedResults, alertMap)
	}

	log.Printf("Detailed results for scan ID %s: %+v\n", scanID, detailedResults)
	return detailedResults, nil
}
