package sql_injection

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
)

type ZAPClient struct {
	APIKey  string
	BaseURL string
}

func NewZAPv2WithAPIKey(apiKey string) *ZAPClient {
	return &ZAPClient{
		APIKey:  apiKey,
		BaseURL: "http://localhost:8080",
	}
}

func (client *ZAPClient) SQLInjectionScan(target string) (string, error) {
	url := fmt.Sprintf("%s/JSON/ascan/action/scan/?apikey=%s&url=%s", client.BaseURL, client.APIKey, target)
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("error starting SQL injection scan: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		return "", fmt.Errorf("error starting SQL injection scan: received status code %d, response body: %s", resp.StatusCode, string(body))
	}

	var result map[string]interface{}
	body, _ := ioutil.ReadAll(resp.Body)
	err = json.Unmarshal(body, &result)
	if err != nil {
		return "", fmt.Errorf("error unmarshalling response: %v", err)
	}

	scanID, ok := result["scan"].(string)
	if !ok {
		return "", fmt.Errorf("scan ID not found in response")
	}

	return scanID, nil
}

func (client *ZAPClient) SQLInjectionStatus(scanID string) (string, error) {
	url := fmt.Sprintf("%s/JSON/ascan/view/status/?apikey=%s&scanId=%s", client.BaseURL, client.APIKey, scanID)
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("error checking SQL injection status: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		return "", fmt.Errorf("error checking SQL injection status: received status code %d, response body: %s", resp.StatusCode, string(body))
	}

	var result map[string]interface{}
	body, _ := ioutil.ReadAll(resp.Body)
	err = json.Unmarshal(body, &result)
	if err != nil {
		return "", fmt.Errorf("error unmarshalling response: %v", err)
	}

	status, ok := result["status"].(string)
	if !ok {
		return "", fmt.Errorf("status not found in response")
	}

	return status, nil
}

func (client *ZAPClient) SQLInjectionResults(scanID string) ([]map[string]interface{}, error) {
	url := fmt.Sprintf("%s/JSON/core/view/alerts/?apikey=%s&baseurl=%s", client.BaseURL, client.APIKey, scanID)
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("error retrieving SQL injection results: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("error retrieving SQL injection results: received status code %d, response body: %s", resp.StatusCode, string(body))
	}

	var result map[string]interface{}
	body, _ := ioutil.ReadAll(resp.Body)
	err = json.Unmarshal(body, &result)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling response: %v", err)
	}

	alerts, ok := result["alerts"].([]interface{})
	if !ok {
		return nil, fmt.Errorf("alerts not found in response")
	}

	var detailedResults []map[string]interface{}
	for _, alert := range alerts {
		alertMap, ok := alert.(map[string]interface{})
		if !ok {
			continue
		}
		detailedResults = append(detailedResults, alertMap)
	}

	return detailedResults, nil
}
