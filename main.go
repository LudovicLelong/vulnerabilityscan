package main

import (
	"encoding/json"
	"fmt"
	"github.com/rs/cors"
	"io/ioutil"
	"log"
	"net/http"
	"time"
	active_scan "vulnerabilityscan/zap-active-scan"
	zap_spider_url "vulnerabilityscan/zap-spider-url"
)

type ScanRequest struct {
	APIKey              string `json:"api_key"`
	Target              string `json:"target"`
	TargetForActiveScan string `json:"target_for_active_scan"`
}

func startSpiderScanHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("Received request to start spider scan")

	// Lire et vérifier le corps de la requête
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Unable to read request body", http.StatusBadRequest)
		log.Printf("Error reading request body: %v", err)
		return
	}
	log.Printf("Request body: %s", string(body))

	var request ScanRequest
	err = json.Unmarshal(body, &request)
	if err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		log.Printf("Error decoding JSON: %v", err)
		return
	}

	log.Printf("Decoded request: %+v\n", request)

	zapClient := zap_spider_url.NewZAPv2WithAPIKey(request.APIKey)
	zapClient.Target = request.Target

	log.Printf("Spider target: %s\n", zapClient.Target)

	// Utiliser le Traditional Spider Scan
	scanID, err := zapClient.SpiderScan()
	if err != nil {
		http.Error(w, fmt.Sprintf("Erreur lors du démarrage du Traditional Spider: %v", err), http.StatusInternalServerError)
		log.Printf("Error starting spider scan: %v", err)
		return
	}
	log.Printf("Scan ID: %s\n", scanID)

	timeout := time.Now().Add(5 * time.Minute)
	for {
		status, err := zapClient.SpiderStatus(scanID)
		if err != nil {
			http.Error(w, fmt.Sprintf("Erreur lors de la vérification du statut du Spider: %v", err), http.StatusInternalServerError)
			log.Printf("Error checking spider status: %v", err)
			return
		}
		log.Printf("Spider status: %s%%\n", status)
		if status == "100" { // Vérifiez si le Spider est à 100%
			log.Println("Spider a terminé à 100%")
			break
		}
		if time.Now().After(timeout) {
			http.Error(w, "Timeout atteint", http.StatusGatewayTimeout)
			log.Printf("Timeout reached for spider scan ID: %s", scanID)
			return
		}
		time.Sleep(2 * time.Second)
	}

	log.Println("Spider completed")
	results, err := zapClient.SpiderResults(0, 100)
	if err != nil {
		http.Error(w, fmt.Sprintf("Erreur lors de l'obtention des résultats du Spider: %v", err), http.StatusInternalServerError)
		log.Printf("Error getting spider results: %v", err)
		return
	}

	log.Printf("Nombre de résultats du Spider: %d\n", len(results))
	log.Printf("Spider results: %v\n", results)

	response := map[string]interface{}{
		"scan_id": scanID,
		"results": results,
	}
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.Printf("Error encoding response: %v", err)
	}
}

func startActiveScanHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("Received request to start Active Scan")

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Unable to read request body", http.StatusBadRequest)
		log.Printf("Error reading request body: %v", err)
		return
	}
	log.Printf("Request body: %s", string(body))

	var request ScanRequest
	err = json.Unmarshal(body, &request)
	if err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		log.Printf("Error decoding JSON: %v", err)
		return
	}

	log.Printf("Decoded request: %+v\n", request)

	zapClient := active_scan.NewZAPv2()
	err = zapClient.StopScan()
	if err != nil {
		http.Error(w, "Failed to stop previous scans", http.StatusInternalServerError)
		log.Printf("Error stopping previous scans: %v", err)
		return
	}

	log.Printf("Starting Active Scan for URL: %s\n", request.TargetForActiveScan)
	scanID, err := zapClient.StartActiveScan(request.TargetForActiveScan)
	if err != nil {
		http.Error(w, "Failed to start active scan", http.StatusInternalServerError)
		log.Printf("Error starting active scan: %v", err)
		return
	}
	log.Printf("Scan ID: %s\n", scanID)

	timeout := time.Now().Add(10 * time.Minute)
	for {
		status, err := zapClient.ScanStatus(scanID)
		if err != nil {
			http.Error(w, "Failed to get scan status", http.StatusInternalServerError)
			log.Printf("Error getting scan status: %v", err)
			return
		}
		log.Printf("Active Scan status for URL %s: %s%%\n", request.TargetForActiveScan, status)
		if status == "100" {
			log.Printf("Active Scan for URL %s completed at 100%%\n", request.TargetForActiveScan)
			break
		}
		if time.Now().After(timeout) {
			http.Error(w, "Timeout reached for active scan", http.StatusGatewayTimeout)
			log.Printf("Timeout reached for active scan ID: %s", scanID)
			return
		}
		time.Sleep(2 * time.Second)
	}

	log.Println("Retrieving Active Scan results")
	results, err := zapClient.ScanResults(request.TargetForActiveScan)
	if err != nil {
		http.Error(w, "Failed to retrieve scan results", http.StatusInternalServerError)
		log.Printf("Error retrieving scan results: %v", err)
		return
	}

	log.Printf("Number of results: %d\n", len(results))
	log.Printf("Scan results: %+v\n", results)

	response := map[string]interface{}{
		"url":     request.TargetForActiveScan,
		"results": results,
	}
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.Printf("Error encoding response: %v", err)
	}
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/start-spider-scan", startSpiderScanHandler)
	mux.HandleFunc("/start-active-scan", startActiveScanHandler)

	handler := cors.Default().Handler(mux)

	log.Println("Server running on port 8082")
	log.Fatal(http.ListenAndServe(":8082", handler))
}

/*
type ScanRequest struct {
	APIKey                string   `json:"api_key"`
	Target                string   `json:"target"`                   // for startSpiderScanHandler
	TargetForSQLInjection []string `json:"target_for_sql_injection"` // for startSQLInjectionScanHandler
}

func startSQLInjectionScanHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("Received request to start SQL injection scan")

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Unable to read request body", http.StatusBadRequest)
		log.Printf("Error reading request body: %v", err)
		return
	}
	log.Printf("Request body: %s", string(body))

	var request ScanRequest
	err = json.Unmarshal(body, &request)
	if err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		log.Printf("Error decoding JSON: %v", err)
		return
	}

	log.Printf("Decoded request: %+v\n", request)

	zapClient := sql_injection.NewZAPv2WithAPIKey(request.APIKey)

	var results []map[string]interface{}
	for _, url := range request.TargetForSQLInjection {
		log.Printf("Started SQL Injection scan for URL %s\n", url)
		scanID, err := zapClient.SQLInjectionScan(url)
		if err != nil {
			log.Printf("Error starting SQL Injection scan for URL %s: %v\n", url, err)
			continue
		}

		// Wait for the scan to complete
		timeout := time.Now().Add(10 * time.Minute) // Augmenter le timeout
		var lastStatus string
		var sameStatusCount int
		for {
			status, err := zapClient.SQLInjectionStatus(scanID)
			if err != nil {
				log.Printf("Error checking SQL Injection status for URL %s: %v\n", url, err)
				break
			}
			log.Printf("SQL Injection status for URL %s: %s%%\n", url, status)
			if status == "100" {
				log.Printf("SQL Injection scan for URL %s completed at 100%%\n", url)
				break
			}
			if time.Now().After(timeout) {
				log.Printf("Timeout reached for SQL Injection scan for URL %s\n", url)
				break
			}
			if status == lastStatus {
				sameStatusCount++
			} else {
				sameStatusCount = 0
			}
			lastStatus = status
			if sameStatusCount > 30 { // Arrêter si le statut reste inchangé pendant 30 itérations
				log.Printf("Scan stuck at %s%% for URL %s\n", status, url)
				break
			}
			time.Sleep(2 * time.Second)
		}

		// Get the results
		detailedResults, err := zapClient.SQLInjectionResults(scanID)
		if err != nil {
			log.Printf("Error retrieving SQL Injection results for URL %s: %v\n", url, err)
			continue
		}
		results = append(results, detailedResults...)
	}

	response := map[string]interface{}{
		"results": results,
	}
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.Printf("Error encoding response: %v", err)
	}
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/start-sql-injection-scan", startSQLInjectionScanHandler)

	handler := cors.Default().Handler(mux)

	log.Println("Server running on port 8082")
	log.Fatal(http.ListenAndServe(":8082", handler))
}
*/
