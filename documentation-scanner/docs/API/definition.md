---
sidebar_position: 1
title: "Explication de l'API utilisé"
---

## Pourquoi une API ?
Une API est la solution que j'ai utilisée pour faire le lien entre le front-end du site et le back-end (l'API). J'ai donc la contrainte dans la construction de l'API de fournir, avant de lancer la requête vers le serveur, la clé d'API ZAP que je veux utiliser et l'adresse de destination dont je veux connaître le plus de points d'entrée possible.


## Pour faire fonctionner l'API

Mettez ce code dans le main : 

```
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"
	"vulnerabilityscan/zap-spider-url"
)

type ScanRequest struct {
	APIKey string `json:"api_key"`
	Target string `json:"target"`
}

func startSpiderScanHandler(w http.ResponseWriter, r *http.Request) {
	var request ScanRequest
	err := json.NewDecoder(r.Body).Decode(&request)
	if err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		return
	}

	zapClient := zap_spider_url.NewZAPv2WithAPIKey(request.APIKey)
	zapClient.Target = request.Target

	fmt.Printf("Spider target %s\n", zapClient.Target)

	// Utiliser le Traditional Spider Scan
	scanID, err := zapClient.SpiderScan()
	if err != nil {
		http.Error(w, fmt.Sprintf("Erreur lors du démarrage du Traditional Spider: %v", err), http.StatusInternalServerError)
		return
	}
	fmt.Printf("Scan ID: %s\n", scanID)

	timeout := time.Now().Add(5 * time.Minute)
	for {
		status, err := zapClient.SpiderStatus(scanID)
		if err != nil {
			http.Error(w, fmt.Sprintf("Erreur lors de la vérification du statut du Spider: %v", err), http.StatusInternalServerError)
			return
		}
		if status == "100" { // Vérifiez si le Spider est à 100%
			fmt.Println("Spider a terminé à 100%")
			break
		}
		if time.Now().After(timeout) {
			http.Error(w, "Timeout atteint", http.StatusGatewayTimeout)
			return
		}
		fmt.Printf("Spider status: %s%%\n", status) // Affiche le pourcentage de progression
		time.Sleep(2 * time.Second)
	}

	fmt.Println("Spider completed")
	results, err := zapClient.SpiderResults(0, 100)
	if err != nil {
		http.Error(w, fmt.Sprintf("Erreur lors de l'obtention des résultats du Spider: %v", err), http.StatusInternalServerError)
		return
	}

	fmt.Printf("Nombre de résultats du Spider: %d\n", len(results))
	fmt.Println("Spider results:", results)

	response := map[string]interface{}{
		"scan_id": scanID,
		"results": results,
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func main() {
	http.HandleFunc("/start-spider-scan", startSpiderScanHandler)
	log.Println("Server running on port 8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

```

J'ai du ajouter un handler pour gérer le probléme cross platform de sécurité de Google, voici le code adapté : 


```
package main

import (
	"encoding/json"
	"fmt"
	"github.com/rs/cors"
	"io/ioutil"
	"log"
	"net/http"
	"time"
	"vulnerabilityscan/zap-spider-url"
)

type ScanRequest struct {
	APIKey string `json:"api_key"`
	Target string `json:"target"`
}

func startSpiderScanHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("Received request to start spider scan")

	// Lire et vérifier le corps de la requête
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Unable to read request body", http.StatusBadRequest)
		log.Printf("Error reading request body: %v", err)
		return
	}
	log.Printf("Request body: %s", string(body))

	var request ScanRequest
	err = json.Unmarshal(body, &request)
	if err != nil {
		http.Error(w, "Invalid request payload", http.StatusBadRequest)
		log.Printf("Error decoding JSON: %v", err)
		return
	}

	log.Printf("Decoded request: %+v\n", request)

	zapClient := zap_spider_url.NewZAPv2WithAPIKey(request.APIKey)
	zapClient.Target = request.Target

	log.Printf("Spider target: %s\n", zapClient.Target)

	// Utiliser le Traditional Spider Scan
	scanID, err := zapClient.SpiderScan()
	if err != nil {
		http.Error(w, fmt.Sprintf("Erreur lors du démarrage du Traditional Spider: %v", err), http.StatusInternalServerError)
		log.Printf("Error starting spider scan: %v", err)
		return
	}
	log.Printf("Scan ID: %s\n", scanID)

	timeout := time.Now().Add(5 * time.Minute)
	for {
		status, err := zapClient.SpiderStatus(scanID)
		if err != nil {
			http.Error(w, fmt.Sprintf("Erreur lors de la vérification du statut du Spider: %v", err), http.StatusInternalServerError)
			log.Printf("Error checking spider status: %v", err)
			return
		}
		log.Printf("Spider status: %s%%\n", status)
		if status == "100" { // Vérifiez si le Spider est à 100%
			log.Println("Spider a terminé à 100%")
			break
		}
		if time.Now().After(timeout) {
			http.Error(w, "Timeout atteint", http.StatusGatewayTimeout)
			log.Printf("Timeout reached for spider scan ID: %s", scanID)
			return
		}
		time.Sleep(2 * time.Second)
	}

	log.Println("Spider completed")
	results, err := zapClient.SpiderResults(0, 100)
	if err != nil {
		http.Error(w, fmt.Sprintf("Erreur lors de l'obtention des résultats du Spider: %v", err), http.StatusInternalServerError)
		log.Printf("Error getting spider results: %v", err)
		return
	}

	log.Printf("Nombre de résultats du Spider: %d\n", len(results))
	log.Printf("Spider results: %v\n", results)

	response := map[string]interface{}{
		"scan_id": scanID,
		"results": results,
	}
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		log.Printf("Error encoding response: %v", err)
	}
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/start-spider-scan", startSpiderScanHandler)

	handler := cors.Default().Handler(mux)

	log.Println("Server running on port 8082")
	log.Fatal(http.ListenAndServe(":8082", handler))
}

```
