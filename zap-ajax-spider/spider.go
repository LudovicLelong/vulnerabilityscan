package ajax_spider

import (
	"encoding/json"
	"fmt"
	"net/url"
	"regexp"
	"time"
)

func (zap *ZAPv2) AjaxSpiderScan() (string, error) {
	params := url.Values{}
	params.Add("url", Target)

	body, err := zap.Request("/JSON/ajaxSpider/action/scan/", params)
	if err != nil {
		return "", err
	}

	fmt.Println("Response from AJAX Spider Scan:", string(body)) // Log supplémentaire

	var result map[string]interface{}
	if err := json.Unmarshal(body, &result); err != nil {
		return "", err
	}

	if code, exists := result["code"].(string); exists && code == "scan_in_progress" {
		return "", fmt.Errorf("scan in progress")
	}

	if result["Result"] != "OK" {
		return "", fmt.Errorf("failed to start AJAX spider scan: %v", result["Result"])
	}

	return "1", nil
}

func (zap *ZAPv2) AjaxSpiderStatus(scanID string) (string, string, error) {
	params := url.Values{}
	params.Add("scanId", scanID)

	body, err := zap.Request("/JSON/ajaxSpider/view/status/", params)
	if err != nil {
		return "", "", err
	}

	fmt.Println("Full response from AJAX Spider Status:", string(body)) // Log complet de la réponse

	var status SpiderStatus
	if err := json.Unmarshal(body, &status); err != nil {
		return "", "", err
	}

	progress := status.Progress
	if progress == "" {
		progress = "N/A"
	}

	return status.Status, progress, nil
}

func (zap *ZAPv2) WaitForScanToComplete(scanID string) error {
	for {
		status, progress, err := zap.AjaxSpiderStatus(scanID)
		if err != nil {
			return err
		}

		if status == "stopped" {
			break
		}

		fmt.Printf("Scan ID: %s, Progress: %s%%\n", scanID, progress)
		time.Sleep(5 * time.Second)
	}
	return nil
}

func (zap *ZAPv2) AjaxSpiderResults(start, count int) ([]SpiderResult, error) {
	params := url.Values{}
	params.Add("start", fmt.Sprintf("%d", start))
	params.Add("count", fmt.Sprintf("%d", count))

	body, err := zap.Request("/JSON/ajaxSpider/view/results/", params)
	if err != nil {
		return nil, err
	}

	fmt.Println("Response from AJAX Spider Results:", string(body)) // Log supplémentaire

	var results SpiderResults
	if err := json.Unmarshal(body, &results); err != nil {
		return nil, err
	}

	// Extraire les URLs des en-têtes de requête
	for i := range results.Results {
		results.Results[i].URL = extractURLFromRequestHeader(results.Results[i].RequestHeader)
	}

	return results.Results, nil
}

func extractURLFromRequestHeader(requestHeader string) string {
	re := regexp.MustCompile(`(GET|POST) ([^\s]+)`)
	matches := re.FindStringSubmatch(requestHeader)
	if len(matches) > 2 {
		return matches[2]
	}
	return ""
}
